



// MARK: -

extension Array where Element : Hashable {
    var hashValue: Int {
        return self.reduce(5381) {
            ($0 << 5) &+ $0 &+ $1.hashValue
        }
    }
}


extension Array {


    func permuter<T:Hashable>() -> (
        (before:[T]) -> ( (after:[T]) -> [Element])
        )
    {
        return {
            (before) in return {
                (after) in return
                self.permute(before,after:after)
            }

        }

    }

    func permute<T:Hashable>(_ before:[T], after:[T]) -> [Element] {
        assert(Set(before) == Set(after))
        assert(before.count == after.count)
        assert(self.count == before.count)

        let beforeIndices = before.elementPlaces
        let afterIndices = after.elementPlaces

        var target = self

        for (key,sourceIndices) in beforeIndices {
            guard let targetIndices = afterIndices[key] else {
                assert(false)
                break
            }
            // assert(sourceIndices.count == targetIndices.count)
            if sourceIndices.count != targetIndices.count {
            }

            for (sourceIndex, targetIndex) in zip(sourceIndices, targetIndices) {
                target[targetIndex] = self[sourceIndex]
            }
        }

        return target
    }
}

// MARK: -

extension Range where Element : Comparable {
    /// expands range if value is not in range
    /// - successor `struct Range<Element : ForwardIndexType>`
    ///
    /// - `func min<T : Comparable>(x: T, _ y: T) -> T`
    ///
    /// - `func max<T : Comparable>(x: T, _ y: T) -> T`
    mutating func insert(_ value:Element) {
        guard !self.contains(value) else { return }

        self.startIndex = min(self.startIndex, value)
        self.endIndex = max(self.endIndex, <#T##Collection corresponding to `value`##Collection#>.index(after: value))
    }
}

extension Sequence where Iterator.Element : Comparable {
    typealias E = Iterator.Element
    func minMaxElementPair() -> (E,E)? {
        return self.reduce(nil) {
            (pair:(E,E)?, element:E) -> (E,E)? in
            guard let (inmin, inmax) = pair else {
                return (element,element) // first element of sequence is minimum and maximum so far
            }
            return (min(inmin,element), max(inmax,element))
        }
    }
}

extension Range where Element: Comparable {
    /// create range such that all elements in the sequence are in the range
    init?<S:Sequence where S.Iterator.Element == Element>(sequence: S) {
        guard let (minimum,maximum) = sequence.minMaxElementPair()
            else { return nil } // empty sequence has neihter minimum nor maximum.
        assert (minimum <= maximum)
        self = minimum...maximum
    }
}

// MARK: -

extension Dictionary {
    // get all keys where the values match a predicate
    func keys(_ predicate : (Element)->Bool) -> [Key] {
        return self.filter { predicate($0) }.map { $0.0
      // for connective in [
      //   "?", "!", "~", "-->",
      //   "&",  "|",  "=>", "<=>", "=",
      //   "~&", "~|", "<=", "<~>", "~="
      // ] {
      //   if self.contains(connective) { return (self,.fof) }
      // } }
    }
}


// MARK: -


// MARK: -

extension Collection
where Iterator.Element : CustomStringConvertible {
    func joinWithSeparator(_ separator:String) -> String {
        return self.map { $0.description }.joined(separator: separator)
    }
}




// MARK: -

extension Sequence {

    func all(_ predicate: (Iterator.Element) -> Bool) -> Bool {
        return self.reduce(true) { $0 && predicate($1) }
    }

    func one(_ predicate: (Iterator.Element) -> Bool) -> Bool {
        return self.reduce(false) { $0 || predicate($1) }
    }

    func count(_ predicate: (Iterator.Element) -> Bool) -> Int {
        return self.reduce(0) { $0 + (predicate($1) ? 1 : 0) }
    }
}



extension Sequence where Iterator.Element : Hashable {
    typealias Element = Iterator.Element

    var elementPlaces : [Element : [Int]] {
        var eo = [Element : [Int]]()
        for (index,value) in self.enumerated() {
            var array = eo[value] ?? [Int]()
            array.append(index)
            eo[value] = array
        }
        return eo
    }

    var elementCounts : [Element: Int] {
        var ec = [Element : Int]()
        for value in self {
            var count = ec[value] ?? 0
            count += 1
            ec[value] = count
        }

        return ec
    }
}

/// cartesic product of two sequences
func *<L,R,LS:Sequence,RS:Sequence where LS.Iterator.Element==L, RS.Iterator.Element == R>(lhs:LS,rhs:RS) -> [(L,R)] {
    var a  = [(L,R)]()
    for l in lhs {
        for r in rhs {
            a.append((l,r))

        }
    }
    return a
}

// MARK: -


extension Set {
    mutating func uniqueify(_ member: inout Element) {
        guard let index = self.index(of: member) else {
            self.insert(member)
            return
        }

        member = self[index]
    }
}

//extension Double {
//    init<I:IntegerType>(_ v:I) {
//        assert(false, "\(#function) \(v)")
//        self = 0.0
//    }
//}
//
//extension IntegerType {
//    init(_ v:Double) {
//        assert(false, "\(#function) \(v)")
//        self = 0
//    }
//}
//
//func percent<I:IntegerType>(dividend:I, divisor:I) -> I {
//    let result = 0.5 + 100.0 * (Double(dividend) / Double(divisor))
//    return I(result)
//}

func percent(_ dividend:Int, divisor:Int) -> Int {
    let result = 0.5 + 100.0 * (Double(dividend) / Double(divisor))
    return Int(result)
}

extension Int {
    /// decode first component
    var first: Int {
        return self >> 32
    }

    /// decode second component
    var second: Int {
        return (self << 32) >> 32
    }

    /// encode two ints into one (this can overflow)
    init(first:Int,second:Int) {

        assert(Int(Int32.min) <= first && first <= Int(Int32.max), "Clause index \(first) is not in range \((Int32.min,Int32.max))")
        assert(Int(Int32.min) <= second && second <= Int(Int32.max), "Literal index \(second) is not in range \((Int32.min,Int32.max))")

        self = (first << 32) ^ (second & 0x0000_0000_FFFF_FFFF)
    }
}

// MARK: - mingy helpers



func eqfunc(_ symbols:[String : SymbolQuadruple]) -> (hasequations:Bool, functors:[(String, SymbolQuadruple)]) {
    let hasequations = symbols.reduce(false) { (a:Bool,b:(String,SymbolQuadruple)) in a || b.1.category == .equational }
    let functors = symbols.filter { (a:String,q:SymbolQuadruple) in q.category == .functor }
    return (hasequations,functors)
}

func maxarity(_ functors:[(String , SymbolQuadruple)]) -> Int {
    return max(functors.reduce(0) { max($0,$1.1.arity.max) },10)
}

func axioms(_ symbols:[String : SymbolQuadruple]) -> [TptpNode]? {
    Nylog.trace("\(#function) \(#line) \(#file)")

    let (hasequations, functors) = eqfunc(globalStringSymbols)

    Nylog.info(hasequations ? "Problem is equational" : "problem is not equational")

    guard hasequations else {
        return nil
    }

    var axioms = [TptpNode]()

    let reflexivity = TptpNode(connective:"|",nodes: ["X=X"])
    let symmetry = "X!=Y|Y=X" as TptpNode
    let transitivity = "X!=Y | Y!=Z | X=Z" as TptpNode

    axioms.append(reflexivity)
    axioms.append(symmetry)
    axioms.append(transitivity)

    let maxArity = maxarity(functors)

    if maxArity > 3 {
        Nylog.warn("The maximum arity \(maxarity) of symbols is too big.")
    }


    let tptpVariables = (1...maxArity).map {
        (TptpNode(variable:"X\($0)"), TptpNode(variable:"Y\($0)"))
    }

    for (symbol,quadruple) in functors {
        Nylog.debug("\(symbol) \(quadruple)")
        var arity = -1
        switch quadruple.arity {
        case .none:
            assert(false)
            break
        case .fixed(let v):
            arity = v
            break
        case .variadic(_):
            assert(false)
            break
        }

        assert(arity < maxArity)

        guard arity > 0 else {
            // c == c
            // ~p | p
            continue
        }

        var literals = [TptpNode]()
        var xargs = [TptpNode]()
        var yargs = [TptpNode]()

        literals.reserveCapacity(arity)

        for i in 0..<arity {
            let (X,Y) = tptpVariables[i]
            let literal = TptpNode(equational:"!=", nodes:[X,Y])
            literals.append(literal)
            xargs.append(X)
            yargs.append(Y)
        }
        switch quadruple.type {
        case .predicate:
            let npx = TptpNode(connective:"~", nodes:[TptpNode(predicate:symbol, nodes:xargs)])
            let py = TptpNode(predicate:symbol, nodes:yargs)
            literals.append(npx)
            literals.append(py)
        case .function:
            let fx = TptpNode(function:symbol, nodes:xargs)
            let fy = TptpNode(function:symbol, nodes:yargs)
            let fx_eq_fy = TptpNode(equational:"=", nodes:[fx,fy])
            literals.append(fx_eq_fy)
        default:
            assert(false)
            break
        }

        let congruence = TptpNode(connective:"|", nodes:literals)
        axioms.append(congruence)

    }

    return axioms
}
*/
